<!DOCTYPE html>

<head>
  <title>MIR Graph</title>
  <style>
    * {
      box-sizing: border-box;
    }

    .block {
      position: absolute;
      border: 1px solid black;
      background-color: white;

      h2 {
        font-size: inherit;
        text-align: center;
        margin: 0;
        background-color: black;
        color: white;
        padding: 0 1rem;
      }

      .instructions {
        padding: 0.5rem 1rem;
      }
    }

    #container {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
    }
  </style>
</head>

<body>
  <div id="container" style="left: 20px; top: 20px"></div>
  <script>
    const DUMMY_WIDTH = 12;
    const GAP_ABOVE_CHILDREN = 36;
    const TRACK_GAP = 24;
    const LOOP_INDENT = 36;
    const BACKEDGE_DEDENT = LOOP_INDENT;

    const PORT_START = 16;
    const PORT_SPACING = 36;
    const ARROW_RADIUS = 10;

    class Graph {
      constructor(container, blocks) {
        this.blocks = blocks;
        this.byNum = {};
        this.tracks = [];
        this.els = {};

        for (const block of blocks) {
          this.byNum[block.number] = block;
          if (block.successors.length === 2) {
            // HACK: Swap the true and false branches of tests
            const tmp = block.successors[0];
            block.successors[0] = block.successors[1];
            block.successors[1] = tmp;
          }

          const el = document.createElement("div");
          el.classList.add("block");
          let html = "";
          let desc = "";
          if (block.attributes.includes("loopheader")) {
            desc = " (loop header)";
          } else if (block.attributes.includes("backedge")) {
            desc = " (backedge)";
          }
          desc += ` (LD=${block.loopDepth})`;
          html += `<h2>Block ${block.number}${desc}</h2>`;
          html += `<div class="instructions">`;
          for (const ins of block.instructions) {
            html += `<div>${ins.id} ${ins.opcode}</div>`;
          }
          html += "</div>";
          el.innerHTML = html;
          container.appendChild(el);
          this.els[block.number] = el;

          block.contentSize = {
            x: el.clientWidth,
            y: el.clientHeight,
          };
          block.pos = { x: 0, y: 0 };

          // Lock the element to its initially rendered size plus fudge factor because text sucks
          el.style.width = `${block.contentSize.x + 10}px`;
          el.style.height = `${block.contentSize.y}px`;
        }

        this.layout();
        this.render();
      }

      successorBlocks(block) {
        return block.successors.map(id => this.byNum[id]);
      }

      layout() {
        const firstBlock = this.blocks[0]; // TODO: Determine first block from graph instead of number

        // Process:
        // - Find loops and assign loop IDs to each block. Use loop header ID as loop ID.
        // - Sort blocks into layers.
        // - ...TODO

        this.findLoops(firstBlock);
      }

      // Walks through the graph tracking which loop each block belongs to. As
      // each block is visited, it is assigned the current loop ID. If the
      // block has lesser loopDepth than its parent, that means it is outside
      // at least one loop, and the loop it belongs to can be looked up by loop
      // depth.
      findLoops(block, loopsByDepth = [null]) {
        const lookupDepth = block.attributes.includes("loopheader") ? block.loopDepth - 1 : block.loopDepth;
        if (lookupDepth < loopsByDepth.length - 1) {
          loopsByDepth = loopsByDepth.slice(0, lookupDepth + 1);
        }
        assert(lookupDepth < loopsByDepth.length);
        block.loopID = loopsByDepth[lookupDepth];

        if (block.attributes.includes("loopheader")) {
          assert(block.loopDepth === loopsByDepth.length);
          loopsByDepth = [...loopsByDepth, block.number];
        }

        if (!block.attributes.includes("backedge")) {
          for (const succ of this.successorBlocks(block)) {
            this.findLoops(succ, loopsByDepth);
          }
        }
      }

      render() {
        // Position all blocks according to layout
        for (const block of this.blocks) {
          const el = this.els[block.number];
          el.style.left = `${block.pos.x}px`;
          el.style.top = `${block.pos.y}px`;
        }

        let maxX = 0, maxY = 0;
        for (const block of this.blocks) {
          maxX = Math.max(maxX, block.pos.x + block.contentSize.x);
          maxY = Math.max(maxY, block.pos.y + block.contentSize.y);
        }

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", maxX);
        svg.setAttribute("height", maxY + GAP_ABOVE_CHILDREN);
        window.container.appendChild(svg);

        layouter.renderArrows(this.blocks, svg);

        // Render arrows
        for (const block of this.blocks) {
          if (block.attributes.includes("backedge")) {
            const header = this.byNum[block.successors[0]];
            const x1 = block.pos.x + PORT_START;
            const y1 = block.pos.y;
            const x2 = header.pos.x;
            const y2 = header.pos.y + PORT_START;
            const arrow = loopHeaderArrow(x1, y1, x2, y2, ARROW_RADIUS);
            arrow.setAttribute("data-edge", `${block.number} -> ${header.number}`);
            svg.appendChild(arrow);
          } else {
            const successors = block.successors.map(id => this.byNum[id]);
            for (const [i, succ] of successors.entries()) {
              const x1 = block.pos.x + PORT_START + PORT_SPACING * i;
              const y1 = block.pos.y + block.contentSize.y;

              if (succ.attributes.includes("backedge")) {
                const x2 = succ.pos.x + PORT_START;
                const y2 = succ.pos.y + succ.contentSize.y;
                const ym = y1 + GAP_ABOVE_CHILDREN / 2;
                const arrow = backedgeArrow(x1, y1, x2, y2, ym, ARROW_RADIUS);
                arrow.setAttribute("data-edge", `${block.number} -> ${succ.number}`);
                svg.appendChild(arrow);
              } else {
                const x2 = succ.pos.x + PORT_START;
                const y2 = succ.pos.y;
                const ym = y1 + GAP_ABOVE_CHILDREN / 2;
                // const ym = y2 - GAP_ABOVE_CHILDREN / 2;
                const arrow = downwardArrow(x1, y1, x2, y2, ym, ARROW_RADIUS);
                arrow.setAttribute("data-edge", `${block.number} -> ${succ.number}`);
                svg.appendChild(arrow);
              }
            }
          }
        }
      }
    }

    function downwardArrow(x1, y1, x2, y2, ym, r, stroke = 1) {
      assert(y1 + r <= ym && ym < y2 - r, `x1 = ${x1}, y1 = ${y1}, x2 = ${x2}, y2 = ${y2}, ym = ${ym}, r = ${r}`);

      let path = "";
      path += `M ${x1} ${y1} `; // move to start

      if (Math.abs(x2 - x1) < 2 * r) {
        // Degenerate case where the radii won't fit; fall back to bezier.
        path += `C ${x1} ${y1 + (y2 - y1) / 3} ${x2} ${y1 + 2 * (y2 - y1) / 3} ${x2} ${y2}`;
      } else {
        const dir = Math.sign(x2 - x1);
        path += `L ${x1} ${ym - r} `; // line down
        path += `A ${r} ${r} 0 0 ${dir > 0 ? 0 : 1} ${x1 + r * dir} ${ym} `; // arc to joint
        path += `L ${x2 - r * dir} ${ym} `; // joint
        path += `A ${r} ${r} 0 0 ${dir > 0 ? 1 : 0} ${x2} ${ym + r} `; // arc to line
        path += `L ${x2} ${y2}`; // line down
      }

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

      const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
      p.setAttribute("d", path);
      p.setAttribute("fill", "none");
      p.setAttribute("stroke", "black");
      p.setAttribute("stroke-width", stroke);
      g.appendChild(p);

      const v = arrowhead(x2, y2, 180);
      g.appendChild(v);

      return g;
    }

    function backedgeArrow(x1, y1, x2, y2, ym, r, stroke = 1) {
      assert(y1 + r <= ym && y2 + r <= ym, `x1 = ${x1}, y1 = ${y1}, x2 = ${x2}, y2 = ${y2}, ym = ${ym}, r = ${r}`);

      let path = "";
      path += `M ${x1} ${y1} `; // move to start
      path += `L ${x1} ${ym - r} `; // line down
      path += `A ${r} ${r} 0 0 1 ${x1 - r} ${ym}`; // arc to joint
      path += `L ${x2 + r} ${ym} `; // joint
      path += `A ${r} ${r} 0 0 1 ${x2} ${ym - r}`; // arc to line
      path += `L ${x2} ${y2}`; // line up

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

      const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
      p.setAttribute("d", path);
      p.setAttribute("fill", "none");
      p.setAttribute("stroke", "black");
      p.setAttribute("stroke-width", stroke);
      g.appendChild(p);

      const v = arrowhead(x2, y2, 0);
      g.appendChild(v);

      return g;
    }

    function loopHeaderArrow(x1, y1, x2, y2, r, stroke = 1) {
      assert(x1 + r <= x2 && y1 - r >= y2, `x1 = ${x1}, y1 = ${y1}, x2 = ${x2}, y2 = ${y2}, r = ${r}`);

      let path = "";
      path += `M ${x1} ${y1} `; // move to start
      path += `L ${x1} ${y2 + r} `; // line up
      path += `A ${r} ${r} 0 0 1 ${x1 + r} ${y2}`; // arc to line
      path += `L ${x2} ${y2} `; // line right

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

      const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
      p.setAttribute("d", path);
      p.setAttribute("fill", "none");
      p.setAttribute("stroke", "black");
      p.setAttribute("stroke-width", stroke);
      g.appendChild(p);

      const v = arrowhead(x2, y2, 90);
      g.appendChild(v);

      return g;
    }

    function arrowhead(x, y, rot, size = 5) {
      const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
      p.setAttribute("d", `M 0 0 L ${-size} ${size * 1.5} L ${size} ${size * 1.5} Z`);
      p.setAttribute("transform", `translate(${x}, ${y}) rotate(${rot})`);
      return p;
    }

    function assert(cond, msg = undefined) {
      if (!cond) {
        throw new Error(msg ?? "Assertion failed");
      }
    }

    (async function () {
      const ion = await (await fetch("ion.json")).json();
      new Graph(window.container, ion.functions[2].passes[0].mir.blocks);
    })();
  </script>
</body>